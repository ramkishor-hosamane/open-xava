<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 5: Lógica de negocio básica - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="Leccion-5-Logica-de-negocio-basica"></a>
        <span id="breadcrumbs"> <span id="openxava"> <a href="https://www.openxava.org/">
              <span>o</span>pen<span>x</span>ava </a> </span> / <a href="index_es.html">documentación</a>
          / </span> Lección 5: Lógica de negocio básica</h1>
       <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="modeling_es.html">2.
        Modelar con Java</a> | <a class="wiki_link" href="testing_es.html">3.
        Pruebas automáticas</a> | <a class="wiki_link" href="inheritance_es.html">4.
        Herencia</a> | <strong>5. Lógica de negocio básica</strong> | <a class="wiki_link"

        href="validation_es.html">6. Validación avanzada</a> | <a class="wiki_link"

        href="refining-standard-behavior_es.html">7. Refinar el comportamiento
        predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">8.
        Comportamiento y lógica de negocio</a> | <a class="wiki_link" href="references-collections_es.html">9.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-5-Logica-de-negocio-basica">Lección
            5: Lógica de negocio básica</a></div>
        <div style="margin-left: 2em;"><a href="#Propiedades-calculadas">Propiedades
            calculadas</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedad-calculada-simple">Propiedad
            calculada simple</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Usar-DefaultValueCalculator">Usar
            @DefaultValueCalculator</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedades-persistentes-con-Calculation">Propiedades
            persistentes con @Calculation</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedades-de-total-de-una-coleccion">Propiedades
            de total de una colección</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades">Valor
            por defecto desde un archivo de propiedades</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Evolucion-de-esquema-manual">Evolución
            de esquema manual</a></div>
        <div style="margin-left: 2em;"><a href="#Metodos-de-retrollamadas-JPA">Métodos
            de retrollamadas JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario">Cálculo
            de valor por defecto multiusuario</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas">Sincronizar
            propiedades persistentes y calculadas</a></div>
        <div style="margin-left: 2em;"><a href="#Logica-desde-la-base-de-datos-Formula">Lógica
            desde la base de datos (@Formula)</a></div>
        <div style="margin-left: 2em;"><a href="#Pruebas-JUnit">Pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Modificar-la-prueba-existente">Modificar
            la prueba existente</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Verificar-valores-por-defecto-propiedades-calculadas-y-Calculation">Verificar
            valores por defecto, propiedades calculadas y @Calculation</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Verificar-Formula">Verificar
            @Formula</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-sincronizacion-de-propiedades-calculadas-y-persistentes">Probar
            sincronización de propiedades calculadas y persistentes</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
      Has convertido tu modelo del dominio en una aplicación web plenamente
      funcional. Esta aplicación ya es bastante útil de por sí, aunque aún
      puedes hacerle muchas mejoras. Transformemos pues tu aplicación en algo
      más serio, y de paso, aprendamos algunas cosas interesantes sobre
      OpenXava.<br>
      Empezaremos por añadir algo de lógica de negocio a tus entidades para
      hacer de tu aplicación algo más que un simple gestor de base de datos.<br>
      <h2 id="toc1"><a name="Propiedades-calculadas"></a>Propiedades calculadas</h2>
      Quizás la lógica de negocio más simple que puedes añadir a tu aplicación
      es una propiedad calculada. Las propiedades que has usado hasta ahora son
      persistentes, es decir, cada propiedad se almacena en una columna de una
      tabla de la base de datos. Una propiedad calculada es una propiedad que no
      almacena su valor en la base de datos, sino que se calcula cada vez que se
      accede a la propiedad. Observa la diferencia entre una propiedad
      persistente y una calculada:<br>
      <pre><code class="java">// Propiedad persistente
private int cantidad; // Tiene un campo, por tanto es persistente
 
public int getCantidad() { // Un getter para devolver el valor del campo
    return cantidad;
}
 
public void setCantidad(int cantidad) { // Cambia el valor del campo
    this.cantidad = cantidad;
}
 
// Propiedad calculada
public int getImporte() { // No tiene campo, ni setter, solo un getter
    return cantidad * precio; // con un cálculo
}
</code></pre> Las propiedades calculadas son reconocidas automáticamente por
      OpenXava. Puedes usarlas en vistas, listas tabulares o cualquier otra
      parte de tu código.<br>
      Vamos a usar propiedades calculadas para añadir el elemento “económico” a
      nuestra aplicación <em>Facturacion</em>. Porque, tenemos líneas de
      detalle, productos, cantidades. Pero, ¿qué pasa con el dinero?<br>
      <h3 id="toc2"><a name="Propiedades-calculadas-Propiedad-calculada-simple"></a>Propiedad
        calculada simple</h3>
      El primer paso será añadir una propiedad de importe a <em>Detalle</em>.
      Lo que queremos es que cuando el usuario elija un producto y teclee la
      cantidad el importe de la línea sea recalculado y mostrado al usuario:<br>
      <img src="files/business-logic_es010.png" alt="business-logic_es010.png" title="business-logic_es010.png"><br>
      Añadir esta funcionalidad a tu actual código es prácticamente añadir una
      propiedad calculada a <em>Detalle</em>. Simplemente añade el código
      siguiente a la clase <em>Detalle</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("producto.numero, cantidad") // Cuando usuario cambie producto o cantidad
public BigDecimal getImporte() { // esta propiedad se recalculará y se redibujará
    if (producto == null || producto.getPrecio() == null) return BigDecimal.ZERO;
    return new BigDecimal(cantidad).multiply(producto.getPrecio());
}
</code></pre>Y los imports correspondientes:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import java.math.*;
import org.openxava.annotations.*;
</code></pre> </div>
    <div class="wiki" style="display: block;"> Es tan solo poner el cálculo en <em>getImporte()</em>
      y usar <em>@Depends</em> para indicar a OpenXava que la propiedad <em>importe</em>
      depende de <em>producto.numero</em> y <em>cantidad</em>, así cada vez
      que el usuario cambia alguno de estos valores la propiedad se recalculará.<br>
      Ahora has de añadir esta nueva propiedad a la lista de propiedades
      mostradas en la colección <em>detalles</em> de <em>DocumentoComercial</em>:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, importe") // importe añadida
private Collection&lt;Detalle&gt; detalles;
</code></pre> Nada más. Tan solo necesitas añadir el getter y modificar la lista
      de propiedades. Ahora puedes probar los módulos <em>Factura</em> y <em>Pedido</em>
      para ver la propiedad <em>importe</em> en acción.<br>
      <h3 id="toc3"><a name="Propiedades-calculadas-Usar-DefaultValueCalculator"></a>Usar
        <em>@DefaultValueCalculator</em></h3>
      La forma en que calculamos el importe de la línea de detalle no es la
      mejor. Tiene, al menos, dos inconvenientes. El primero es que el usuario
      puede querer tener la posibilidad de cambiar el precio unitario. Y
      segundo, si el precio de un producto cambia los importes de todas las
      facturas cambian también, y esto no es bueno.<br>
      Para evitar estos inconvenientes lo mejor es almacenar el precio de cada
      producto en cada línea de detalle. Añadamos pues una propiedad persistente
      <em>precioPorUnidad</em> a la clase <em>Detalle</em> y calculemos su
      valor desde <em>precio</em> de <em>Producto</em> usando un <em>@DefaultValueCalculator</em>.
      De tal forma que consigamos el efecto que puedes ver en la siguiente
      figura:<br>
      <img src="files/business-logic_es020.png" alt="business-logic_es020.png" title="business-logic_es020.png"><br>
      El primer paso es obviamente añadir la propiedad <em>precioPorUnidad</em>.
      Añade el siguiente código a la clase <em>Detalle</em>:<br>
      <pre><code class="java">@DefaultValueCalculator(
    value=CalculadorPrecioPorUnidad.class, // Esta clase calcula el valor inicial
    properties=@PropertyValue(
        name="numeroProducto", // La propiedad numeroProducto del calculador...
        from="producto.numero") // ... se llena con el valor de producto.numero de la entidad
)
@Stereotype("DINERO")
private BigDecimal precioPorUnidad; // Una propiedad persistente convencional...
 
public BigDecimal getPrecioPorUnidad() { // ... con sus getter y setter
    return precioPorUnidad == null ? BigDecimal.ZERO : precioPorUnidad; // Así nunca devuelve nulo
}
 
public void setPrecioPorUnidad(BigDecimal precioPorUnidad) {
    this.precioPorUnidad = precioPorUnidad;
}
</code></pre> <em>CalculadorPrecioPorUnidad</em> contiene la lógica para
      calcular el valor inicial. Simplemente lee el precio del producto. Observa
      el código de este calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete calculadores
 
import org.openxava.calculators.*;
import com.tuempresa.facturacion.modelo.*;
 
import static org.openxava.jpa.XPersistence.*; //Para usar getManager()
 
public class CalculadorPrecioPorUnidad implements ICalculator {
 
    private int numeroProducto;
 
    @Override
    public Object calculate() throws Exception {
        Producto producto = getManager() // getManager() de XPersistence
            .find(Producto.class, numeroProducto); // Busca el producto
        return producto.getPrecio();    // Retorna su precio
    }
 
    public int getNumeroProducto() {
        return numeroProducto;
    }
 
    public void setNumeroProducto(int numeroProducto) {
        this.numeroProducto = numeroProducto;
    }
}
</code></pre> </div>
    <div class="wiki" style="display: block;">También añade el siguiente import
      en la clase <i>Detalle</i>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import com.tuempresa.facturacion.calculadores.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">De esta forma cuando el usuario
      escoge un producto el campo de precio unitario se rellena con el precio
      del producto, pero dado que es una propiedad persistente, el usuario puede
      cambiar este valor. Y si en el futuro el precio del producto cambiara este
      precio unitario de la línea de detalle no cambiaría.<br>
      Esto implica que has de adaptar la propiedad calculada <em>importe</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("precioPorUnidad, cantidad") // precioPorUnidad en vez de producto.numero
public BigDecimal getImporte() {
    // El if ya no es necesario porque getPrecioPorUnidad() nunca devuelve nulo
    return new BigDecimal(cantidad).multiply(getPrecioPorUnidad()); // getPrecioPorUnidad() en vez de producto.getPrecio()
}
</code></pre> Ahora <em>getImporte()</em> usa <em>precioPorUnidad</em> como
      fuente en lugar de <em>producto.precio</em>.<br>
      Finalmente, debemos editar la entidad <em>DocumentoComercial</em> y
      modificar la lista de propiedades de la colección para mostrar la nueva
      propiedad:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, importe") // precioPorUnidad añadida
private Collection&lt;Detalle&gt; detalles;
</code></pre> Prueba los módulos <em>Pedido</em> y <em>Factura</em> y podrás
      observar el nuevo comportamiento al añadir líneas de detalle.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="Propiedades-calculadas-Propiedades-persistentes-con-Calculation"></a>Propiedades
        persistentes con <i>@Calculation</i></h3>
      A veces las propiedades calculadas no son la mejor opción. Imagínate que
      tienes una propiedad calculada en <em>Factura</em>, digamos <em>descuento</em>:<br>
      <div class="wiki" style="display: block;">
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
public BigDecimal getDescuento() {
    return getImporte().multiply(new BigDecimal("0.10"));
}
</code></pre> Si necesitas procesar todas las facturas cuyo descuento sea mayor
        de 1000, has de escribir un código como el siguiente:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
Query query = getManager().createQuery("from Factura"); // Sin condición en la consulta
for (Object o: query.getResultList()) { // Itera por todos los objetos
    Factura f = (Factura) o;
    if (f.getDescuento() // Pregunta a cada objeto
        .compareTo(new BigDecimal("1000")) &gt; 0) {
            i.hacerAlgo();
    }
}
</code></pre> No puedes usar una condición en la consulta para discriminar por <i>descuento</i>,
        porque <i>descuento</i> no está en la base de datos, está sólo en el
        objeto Java, por lo que has de instanciar todos y cada uno de los
        objetos para poder preguntar por el <i>descuento</i>. En algunos casos
        esta forma es una buena opción, pero si tienes una cantidad inmensa de
        facturas y sólo unas pocas tiene el <i>descuento</i> mayor de 1000,
        entonce tu proceso va a ser muy ineficiente. ¿Qué alternativas tenemos?<br>
        Nuestra alternativa es usar la anotación <em>@Calculation</em>. <em>@Calculation</em>
        es una anotación OpenXava que permite asociar un cálculo simple a una
        propiedad persistente. Puedes definir <em>descuento</em> con <em>@Calculation</em>
        como se muestra en el siguiente código:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
@ReadOnly
@Calculation("importe * 0.10")
private BigDecimal descuento;

public BigDecimal getDescuento() {
    return descuento;
}

public void setDescuento(BigDecimal descuento) {
    this.descuento = descuento;
} 
</code></pre> Esto es una propiedad persistente convencional, es decir con una
        columna correspondiente en la base de datos, pero tiene un cálculo
        definido con <i>@Calculation</i>. En este caso el cálculo es <i>importe
          * 0.10</i>, de tal manera que cuando el usuario cambia <i>importe</i>
        en la interfaz de usuario <i>descuento</i> se recalcula
        instantaneamente. El valor recalculado se graba en la base de datos
        cuando el usuario pulsa en <i>Grabar</i>, como con cualquier otra
        propiedad persistente. También hemos anotado <i>descuento</i> con <i>@ReadOnly</i>,
        por lo que parece y se comporta como una propiedad calculada, aunque
        puedes omitir <i>@ReadOnly</i> y así el usuario podría modificar el
        valor calculado.</div>
      <div class="wiki" style="display: block;"> Lo más útil de las propiedades
        <em>@Calculation</em> es que se pueden usar en las condiciones, por lo
        que puedes reescribir el proceso de arriba como se muestra en el
        siguiente código:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
Query query = getManager().createQuery("from Factura f where f.descuento &gt; :descuento"); // Condición permitida
query.setParameter("descuento", new BigDecimal(1000));
for (Object o: query.getResultList()) { // Itera sólo por los objectos seleccionados
    Factura f = (Factura) o;
    f.hacerAlgo();
}
</code></pre>De esta manera ponemos el peso de seleccionar los registros en el
        servidor de la base de datos y no en el servidor Java. Además, los
        descuentos no se recalculan cada vez, sino que ya está calculados y
        grabados.<br>
        Este hecho tiene también efecto en el modo lista, porque el usuario no
        puede filtrar ni ordenar por las propiedades calculadas, pero sí que lo
        puede hacer usando propiedades persistentes con <em>@Calculation</em>:<br>
        <img src="files/business-logic_es025.png" alt="business-logic_es025.png"

          title="business-logic_es025.png"><br>
        <em>@Calculation</em> es una buena opción cuando necesitas filtrar y
        ordenar, y un cálculo simple es suficiente. Una desventaja de las
        propiedades con <i>@Calculation</i> es que sus valores se recalculan
        sólo cuando el usuario interactúa con el registro y cambia algún valor
        de las propiedades usadas en el cálculo, por lo tanto cuando añades una
        nueva propiedad <i>@Calculation</i> a una entidad con datos existente
        has de actualizar los valores de la nueva columna en la tabla usando
        SQL. Por otra parte si necesitas un cálculo complejo, con bucles o
        consultando otras entidades, todavía sigues necesitando una propiedad
        calculada con tu lógica Java en el getter. En este último caso si además
        necesitas ordenar y filtrar en modo lista por la propiedad calculada un
        opción es tener ambas, la calculada y la persistente, y sincronizar sus
        valores usando los métodos de retrollamada de JPA (hablaremos sobre los
        métodos de retrollamada más abajo).</div>
      <h3 id="toc4"><a name="Propiedades-calculadas-Propiedades-de-total-de-una-coleccion"></a>Propiedades
        de total de una colección</h3>
      También queremos añadir importes a <em>Pedido</em> y <em>Factura</em>.
      Tener IVA, importe base e importe total es indispensable. Para hacerlo
      sólo necesitas añadir unas pocas propiedades a la clase <i>DocumentoComercial</i>.
      La siguiente figura muestra la interfaz de usuario para estas propiedades:<br>
      <img src="files/business-logic_es030.png" alt="business-logic_es030.png" title="business-logic_es030.png"><br>
      Añade el siguiente código (y genera los getters y setters) a la entidad <i>DocumentoComercial</i>:<br>
      <pre><code class="java">@Digits(integer=2, fraction=0) // Para indicar su tamaño
private BigDecimal porcentajeIVA;
   
@ReadOnly
@Stereotype("DINERO")
@Calculation("sum(detalles.importe) * porcentajeIVA / 100")
private BigDecimal iva;

@ReadOnly
@Stereotype("DINERO")
@Calculation("sum(detalles.importe) + iva")    
private BigDecimal importeTotal;    

// RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS DE ARRIBA
</code></pre> Para usar <i>BigDecimal</i> y <i>@Digits</i> deberías añadir los
      siguientes imports a <i>DocumentoComercial</i>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import java.math.*;
import javax.validation.constraints.*;
</code></pre> </div>
    <div class="wiki" style="display: block;"> Fíjate como hemos escogido
      propiedades persistentes con <i>@Calculation + @ReadOnly</i> en lugar de
      propiedades calculadas para <i>iva</i> e <i>importeTotal</i>, porque los
      cálculos son simples, y filtrar y ordenar por ellos es muy útil. También,
      puedes ver como en <i>@Calculation</i> puedes usar <i>sum(detalles.importe)</i>
      para referirte a la suma de columna <i>importe</i> de la colección <i>detalles</i>,
      de esta manera podemos prescindir de una propiedad <i>importeBase</i>.
      Por otra parte, <em>porcentajeIVA</em> es un propiedad persistente
      convencional. En este caso usamos <em>@Digits</em> (una anotación de Bean
      Validation, el estándar de validación de Java) como una alternativa a <em>@Column</em>
      para especificar su tamaño. <br>
      Ahora que ya has escrito las propiedades para los importes de <em>DocumentoComercial</em>,
      tienes que modificar la lista de propiedades de la colección <em>detalles</em>
      para mostrar las <a class="wiki_link" href="view_es.html#Vista-Personalizacion+de+coleccion-Propiedades+de+total+%28nuevo+en+v4.3%29">propiedades
        de total</a> de <em>DocumentoComercial</em>. Veámoslo:<br>
      <pre><code class="java">abstract public class DocumentoComercial extends Identificable {
 
    @ElementCollection
    @ListProperties(
        "producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
        "importe+[" + 
        	"documentoComercial.porcentajeIVA," +
        	"documentoComercial.iva," +
        	"documentoComercial.importeTotal" +
        "]" 
    )	
    private Collection&lt;Detalle&gt; detalles;
 
    ...
}
</code></pre>Las propiedades de total son propiedades normales de la entidad (<i>DocumentoComercial</i>
      en este caso) que en la interfaz de usuario se localizan debajo de una
      columna de una colección. Para eso, en <i>@ListProperties</i> se usan
      corchetes después de la propiedad para enumerarlas, algo así como <i>importe[documentoComercial.importeTotal]</i>.
      Además, si simplemente quieres la suma de la columna no necesitas una
      propiedad para ello, con un + después de la propiedad en <i>@ListProperties</i>
      es suficiente, como <i>importe+</i>. En nuestro caso combinamos ambas
      cosas, + y propiedades de total entre [ ].</div>
    <div class="wiki" style="display: block;">Ahora puedes probar tu aplicación.
      Debería funcionar casi como en la figura del inicio de esta sección.
      “Casi” porque <em>porcentajeIVA</em> todavía no tiene un valor por
      defecto. Lo añadiremos en la siguiente sección.<br>
      <h3 id="toc5"><a name="Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades"></a>Valor
        por defecto desde un archivo de propiedades</h3>
      Es conveniente para el usuario tener el campo <em>porcentajeIVA</em>
      lleno por defecto con un valor adecuado. Podrías usar un calculador (<em>@DefaultValueCalculator</em>)
      que devuelva un valor fijo, pero en ese caso cambiar el valor por defecto
      implica cambiar el código fuente. O podrías leer el valor por defecto de
      una base de datos (usando JPA desde tu calculador), pero en ese caso
      cambiar el valor por defecto implica actualizar la base de datos.<br>
      Otra opción es tener estos valores de configuración en un archivo de
      propiedades, un archivo plano con pares clave=valor. En este caso cambiar
      el valor por defecto de <em>porcentajeIVA</em> es tan simple como editar
      un archivo plano con un editor de texto.<br>
      Implementemos la opción del archivo de propiedades. Crea un archivo
      llamado <em>facturacion.properties</em> en la carpeta <em>Facturacion/properties</em>
      con el siguiente contenido:<br>
      <pre><code class="properties">porcentajeIVADefecto=21
</code></pre> Aunque puedes usar la clase <em>java.util.Properties</em> de Java
      para leer este archivo preferimos usar una clase propia para leer estas
      propiedades. Vamos a llamar a esta clase <em>PreferenciasFacturacion</em>
      y la pondremos en un nuevo paquete llamado <em>com.tuempresa.facturacion.util</em>.
      Veamos el código:<br>
      <pre><code class="java">package com.tuempresa.facturacion.util; // En el paquete 'util'
 
import java.io.*;
import java.math.*;
import java.util.*;
import org.apache.commons.logging.*;
import org.openxava.util.*;
 
public class PreferenciasFacturacion {
 
    private final static String ARCHIVO_PROPIEDADES="facturacion.properties";
    private static Log log = LogFactory.getLog(PreferenciasFacturacion.class);
 
    private static Properties propiedades; // Almacenamos las propiedades aquí
 
    private static Properties getPropiedades() {
        if (propiedades == null) { // Usamos inicialización vaga
            PropertiesReader reader = // PropertiesReader es una clase de OpenXava
                new PropertiesReader(
                    PreferenciasFacturacion.class, ARCHIVO_PROPIEDADES);
            try {
                propiedades = reader.get();
            }
            catch (IOException ex) {
                log.error(
                    XavaResources.getString( // Para leer un mensaje i18n
                        "properties_file_error",
                        ARCHIVO_PROPIEDADES),
                    ex);
                  propiedades = new Properties();
             }
        }
        return propiedades;
    }
 
    public static BigDecimal getPorcentajeIVADefecto() { // El único método público
        return new BigDecimal(getPropiedades().getProperty("porcentajeIVADefecto"));
    }
}
</code></pre> Como puedes ver <em>PreferenciasFacturacion</em> es una clase con
      un método estático, <em>getPorcentajeIVADefecto()</em>. La ventaja de
      usar esta clase en lugar de leer directamente del archivo de propiedades
      es que si cambias la forma en que se obtienen las preferencias, por
      ejemplo leyendo de una base de datos o de un directorio LDAP, solo has de
      cambiar esta clase en toda tu aplicación.<br>
      Puedes usar esta clase desde el calculador por defecto para la propiedad <em>porcentajeIVA</em>.
      Aquí tienes el código del calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete 'calculadores'
 
import org.openxava.calculators.*; // Para usar 'ICalculator'
import com.tuempresa.facturacion.util.*; // Para usar 'PreferenciasFacturacion'
 
public class CalculadorPorcentajeIVA implements ICalculator {
 
    @Override
    public Object calculate() throws Exception {
        return PreferenciasFacturacion.getPorcentajeIVADefecto();
    }
}
</code></pre> Como ves, simplemente devuelve <em>porcentajeIVADefecto</em> de <em>PreferenciasFacturacion</em>.
      Ahora, ya puedes usar este calculador en la definición de la propiedad <em>porcentajeIVA</em>
      en <em>DocumentoComercial</em>. Mira el código:<br>
      <pre><code class="java">@DefaultValueCalculator(CalculadorPorcentajeIVA.class)
private BigDecimal porcentajeIVA;
</code></pre> Con este código cuando el usuario pulsa para crear una nueva
      factura, el campo <em>porcentajeIVA</em> se rellenará con 21, o cualquier
      otro valor que hayas puesto en <em>facturacion.properties</em>.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="Propiedades-calculadas-Evolucion-de-esquema-manual"></a>Evolución
        de esquema manual</h3>
      Cuando usamos cosas como <i>@Calculation</i> o <i>@DefaultValueCalculator</i>
      la evolución de esquema automática que provee OpenXava se nos queda corta,
      porque añade una nueva columna cuando tu añades una nueva propiedad, pero
      no rellena la columna con los valores correctos. En este caso hemos
      añadido varias propiedades persistentes con <i>@Calculation</i> cuyos
      valores no se recalculan hasta que el usuario interactua con el registro.
      Además, tenemos un valor por defecto para <i>porcentajeIVA</i> que sólo
      tiene efecto cuando el usuario crea un nuevo registro pero no en los
      registros ya existentes. Hemos de rellenar las nuevas columnas con valores
      razonables.
      <div class="wiki" style="display: block;">Dado que estamos en una etapa
        temprana del desarrollo una buena opción sería borrar todos los
        registros, pero es seguro que esto no es una buena idea para producción,
        por tanto vamos a ajustar nuestra base de datos al nuevo código sin
        perder información para ilustrar la evolución manual de esquema.</div>
      <div class="wiki" style="display: block;">Lo más fácil es usar la propia
        aplicación para hacer las actualizaciones. Vamos a hacerlo para
        actualizar los precios de los productos. Para que las nuevas propiedades
        calculadas funcionen bien todos los productos deberían tener un precio,
        por tanto ve al módulo <i>Producto</i> con tu navegador y asegurate de
        que todos los productos tienen precio:</div>
      <img src="files/business-logic_es040.png" alt="business-logic_es040.png" title="business-logic_es040.png">
      <div class="wiki" style="display: block;">Si algún producto no tiene
        precio edítalo e introduce un precio.</div>
      <div class="wiki" style="display: block;">Los siguientes cambios no son
        tan sencillos, por lo que vamos a ejecutar sentencias SQL contra nuestra
        base de datos. Para ejecutar estas sentencias SQL, primero asegurate de
        que tu aplicación se está ejecutando, entonces ve a la clase <i>DBManager</i>
        en <i>Facturacion/src/_run</i>, y con el botón derecho del ratón escoge
        <i>Run As &gt; Java Application</i>:<br>
        <img src="files/inheritance_es040.png" alt="inheritance_es040.png" title="inheritance_es040.png"><br>
        Ahora estás listo para escribir y ejecutar SQLs. Primero, establecemos
        el valor para la columna <i>precioPorUnidad</i> en todos los detalles:
      </div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL_DETALLES 
SET PRECIOPORUNIDAD = (
    SELECT PRECIO FROM FACTURACION.PRODUCTO 
    WHERE NUMERO = PRODUCTO_NUMERO
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Ahora actualizamos <i>porcentajeIVA</i>
        para todas las facturas:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET PORCENTAJEIVA = 21
</code></pre> </div>
      <div class="wiki" style="display: block;">Lo siguiente es actualizar <i>iva</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET IVA = (
    SELECT SUM(PRECIOPORUNIDAD * CANTIDAD) * 0.21 
    FROM FACTURACION.DOCUMENTOCOMERCIAL_DETALLES D 
    WHERE D.DOCUMENTOCOMERCIAL_OID = DOCUMENTOCOMERCIAL.OID
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Finalmente, actualizamos <i>importeTotal</i>
        en todas las facturas:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET IMPORTETOTAL = (
    SELECT SUM(PRECIOPORUNIDAD * CANTIDAD) * 1.21 
    FROM FACTURACION.DOCUMENTOCOMERCIAL_DETALLES D 
    WHERE D.DOCUMENTOCOMERCIAL_OID = DOCUMENTOCOMERCIAL.OID
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Ten cuidado, las setencias de
        arriba funciona bien con HSQLDB, la base de datos incluida con OpenXava.
        Si usas otra base de datos probablemente tengas que adaptar la sintaxis.
        Después de ejecutar estas sentencias puedes probar tu aplicación.
        Debería funcionar como en la figura al principio de la sección
        "Propiedades de total de una colección" incluso para facturas y pedidos
        ya existentes.</div>
      <h2 id="toc6"><a name="Metodos-de-retrollamadas-JPA"></a>Métodos de
        retrollamadas JPA</h2>
      Otra forma práctica de añadir lógica de negocio a tu modelo es mediante
      los métodos de retrollamada JPA. Un método de retrollamada se llama en un
      momento específico del ciclo de vida de la entidad como objeto
      persistente. Es decir, puedes especificar cierta lógica a ejecutar al
      grabar, leer, borrar o modificar una entidad.<br>
      En esta sección veremos algunas aplicaciones prácticas de los métodos de
      retrollamada JPA.<br>
      <h3 id="toc7"><a name="Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario"></a>Cálculo
        de valor por defecto multiusuario</h3>
      Hasta ahora estamos calculando el número para <em>Factura</em> y <em>Pedido</em>
      usando <em>@DefaultValueCalculator</em>. Éste calcula el valor por
      defecto en el momento que el usuario pulsa para crear una nueva <em>Factura</em>
      o <em>Pedido</em>. Por tanto, si varios usuarios pulsan en el botón <i>Nuevo</i>
      al mismo tiempo todos ellos obtendrán el mismo número. Esto no es apto
      para aplicaciones multiusuario. La forma correcta de generar un número
      único es generándolo justo en el momento de grabar.<br>
      Vamos a implementar la generación del número usando métodos de
      retrollamada JPA. JPA permite marcar cualquier método de tu clase para ser
      ejecutado en cualquier momento de su ciclo de vida. Indicaremos que justo
      antes de grabar un <em>DocumentoComercial</em> calcule su número. De paso
      mejoraremos el cálculo para tener una numeración diferente para <em>Pedido</em>
      y <em>Factura</em>.<br>
      Edita la entidad <em>DocumentoComercial</em> y añade el método <em>calcularNumero()</em>.
      Veamos el código:<br>
      <pre><code class="java">@PrePersist // Ejecutado justo antes de grabar el objeto por primera vez
private void calcularNumero() {
    Query query = XPersistence.getManager().createQuery(
        "select max(f.numero) from " +
        getClass().getSimpleName() + // De esta forma es válido para Factura y Pedido
        " f where f.anyo = :anyo");
    query.setParameter("anyo", anyo);
    Integer ultimoNumero = (Integer) query.getSingleResult();
    this.numero = ultimoNumero == null ? 1 : ultimoNumero + 1;
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Para usar <i>XPersistence</i> has
      de añadir este import:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import org.openxava.jpa.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">Este código es el mismo que el de
      <em>CalculadorSiguienteNumeroParaAnyo</em> pero usando <em>getClass().getSimpleName()</em>
      en lugar de "DocumentoComercial". El método <em>getSimpleName()</em>
      devuelve el nombre de la clase sin paquete, es decir, precisamente el
      nombre de la entidad. Será "Pedido" para <em>Pedido</em> y "Factura" para
      <em>Factura</em>. Así podremos obtener una numeración diferente para <em>Factura</em>
      y <em>Pedido</em>.<br>
      La especificación JPA establece que no puedes usar el API JPA dentro de un
      método de retrollamada. Por tanto, el método de arriba no es legal desde
      un punto de vista estricto. Pero, Hibernate (la implementación de JPA que
      OpenXava usa por defecto) te permite usarla en <em>@PrePersist</em>. Y
      dado que usar JPA es la forma más fácil de hacer este cálculo, nosotros lo
      usamos.<br>
      Ahora borra la clase <em>CalculadorSiguienteNumeroParaAnyo</em> de tu
      proyecto y modifica la propiedad <em>numero</em> de <em>DocumentoComercial</em>
      para que no la use:<br>
      <pre><code class="java">@Column(length = 6)
//  @DefaultValueCalculator(value=CalculadorSiguienteNumeroParaAnyo.class, // Quita esto
//      properties=@PropertyValue(name="anyo")
//  )
@ReadOnly // El usuario no puede modificar el valor
private int numero;
</code></pre> Fíjate que además de quitar <em>@DefaultValueCalculator</em>,
      hemos añadido la anotación <em>@ReadOnly</em>. Esto significa que el
      usuario no puede introducir ni modificar este número. Esta es la forma
      correcta de hacerlo ahora dado que el número es generado al grabar el
      objeto, por lo que el valor que tecleara el usuario sería sobrescrito
      siempre.<br>
      Prueba ahora el módulo de <em>Factura</em> o <em>Pedido</em>, verás como
      el número está vacío y no es editable, y cuando grabes el documento, el
      número se calcula y se muestra un mensaje con el año y el número recién
      calculado para esa factura o pedido.<br>
      <h3 id="toc8"><a name="Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas"></a>Sincronizar
        propiedades persistentes y calculadas</h3>
      Como ya hemos aprendido, las propiedades calculadas no permiten filtrar ni
      ordenar en la lista, por lo que preferimos propiedades transitorias con <i>@Calculation</i>.
      Sin embargo, las propiedades <i>@Calculation</i> sólo sirven para
      cálculos aritméticos simples. Cuando necesitas bucles, condiciones, leer
      de la base de datos, conectar a servicios externos o cualquier lógica
      compleja, <i>@Calculation</i> no es suficiente. Para estos casos
      necesitas escribir la lógica con Java, en el getter. Pero, ¿cómo podemos
      hacer esto y al mismo tiempo mantener la ordenación y el filtrado en la
      lista? Fácil, puedes usar dos propiedades, una calculada y otra
      persistente, y mantenerlas sincronizadas usando los métodos de
      retrollamada de JPA. Vamos a aprender como hacerlo en esta sección.
      <div class="wiki" style="display: block;">Añadamos un nueva propiedad a la
        entidad <i>Pedido</i> llamada <i>diasEntregaEstimados</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">@Depends("fecha")
public int getDiasEntregaEstimados() {
    if (getFecha().getDayOfYear() &lt; 15) {
        return 20 - getFecha().getDayOfYear(); 
    }
    if (getFecha().getDayOfWeek() == DayOfWeek.SUNDAY) return 2;
    if (getFecha().getDayOfWeek() == DayOfWeek.SATURDAY) return 3;
    return 1;
}
</code></pre> </div>
      <div class="wiki" style="display: block;"> Para usar <i>DayOfWeek</i>
        añade el siguiente import en la parte de arriba de <i>Pedido</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">import java.time.*;
</code></pre> </div>
      <div class="wiki" style="display: block;">Esto es una propiedad calculada
        pura, un getter con lógica Java. Calcula los día estimados de entrega
        usando <i>fecha</i> como fuente. Este caso no puede solucionarse con <i>@Calculation</i>
        que solo soporta operaciones aritméticas básicas. </div>
      <div class="wiki" style="display: block;">También hemos de añadir <i>diasEntregaEstimados</i>
        a la declaración de la <i>@View</i> por defecto en el código de <i>Pedido</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">@View(extendsView="super.DEFAULT", 
    members=
        "diasEntregaEstimados," + // ADD THIS LINE
        "factura { factura }"
)
...
public class Pedido extends CommercialDocument {
</code></pre> </div>
      <div class="wiki" style="display: block;">El resultado es este:</div>
      <img src="files/business-logic_es050.png" alt="business-logic_es050.png" title="business-logic_es050.png">
      <div class="wiki" style="display: block;">El valor se recalcula cada vez
        que la fecha cambia en la interfaz de usuario gracias a el <i>@Depends("fecha")</i>
        en <i>diasEntregaEstimados.</i> Todo esto está muy bien, pero cuando
        vas a modo lista no puedes ordenar ni filtrar por los días de entrega
        estimados. Para resolver este problema añadimos una segunda propiedad,
        en esta ocasión una persistente. </div>
      <div class="wiki" style="display: block;">Añade el siguiente código a tu
        entidad <i>Pedido</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">@Column(columnDefinition="INTEGER DEFAULT 1")
private int diasEntrega;
    
public int getDiasEntrega() {
    return diasEntrega;
}

public void setDiasEntrega(int diasEntrega) {
    this.diasEntrega = diasEntrega;
}
</code></pre> </div>
      <div class="wiki" style="display: block;">Fíjate como hemos usado <i>@Column(columnDefinition="INTEGER
          DEFAULT 1")</i>, con este truco cuando OpenXava crea la columna usa
        "INTEGER DEFAULT 1" como definición de columna, así la nueva columna
        tiene 1 como valor por defecto en lugar de nulo y evitamos un feo error
        con nuestra propiedad int. Sí, en muchos casos <i>@Column(columnDefinition=)</i>
        es una alternativa a hacer un UPDATE sobre la tabla (como hicimos en la
        sección "Evolución de esquema manual"), aunque tiene el problema de que
        es dependiente de la base de datos. De cualquier modo, esta disertación
        sobre <i>columnDefinition</i> es tangencial a nuestro asunto sobre
        sincronización entre propiedades calculadas y persistentes, <i>@Column</i>
        no llega a ser necesario, simplemente es conveniente para nuestra
        propiedad int.</div>
      <div class="wiki" style="display: block;">Esta nueva propiedad <i>diasEntrega</i>
        contendrá el mismo valor que <em>diasEntregaEstimados</em>, pero <i><em>diasEntrega</em></i>
        será persistente con su columna correspondiente en la base de datos. El
        truco está en mantener sincronizada la propiedad <em>diasEntrega</em>.
        Usaremos los métodos de retrollamada de JPA en <em>Pedido</em> para
        conseguir esto. Es suficiente con asignar el valor de <i>diasEntregaEstimados</i>
        a <i>diasEntrega</i> cada vez que un nuevo <i>Pedido</i> se crea (<i>@PrePersist</i>)
        o modifica (<i>@PreUpdate</i>).<br>
        Añade un método <i>recalcularDiasEntrega()</i> a la entidad <i>Pedido</i>
        y anótalo con <i>@PrePersist</i> y <i>@PreUpdate</i>, así:<br>
        <pre><code class="java">@PrePersist @PreUpdate 
private void recalcularDiasEntrega() {
    setDiasEntrega(getDiasEntregaEstimados());
}
</code></pre>Básicamente, el método <i>recalcularDiasEntrega()</i> se llama
        cada vez que la entidad <em>Pedido</em> se registra en la base de datos
        por primera vez y cuando se actualiza.</div>
      Puedes probar el módulo <em>Pedido</em> con este código y verás como
      cuando un pedido se crea o modifica, la columna en la base de datos <i>diasEntrega</i>
      se actualiza correctamente después de grabar, lista para usar en procesos
      masivos y disponible para filtrar y ordenar en la lista.<br>
      <h2 id="toc9"><a name="Logica-desde-la-base-de-datos-Formula"></a>Lógica
        desde la base de datos (<em>@Formula</em>)</h2>
      Otra alternativa a <i>@Calculation,</i> o a tener propiedades calculadas
      y persistentes sincronizadas, es la anotación <em>@Formula</em>. <em>@Formula</em>
      es una extensión de Hibernate al estándar JPA, que permite mapear una
      propiedad a un fragmento de SQL. Por ejemplo, puedes definir <i>beneficioEstimado</i>
      con <em>@Formula</em> en <i>DocumentoComercial</i> como se muestra en el
      siguiente código:<br>
      <pre><code class="java">@org.hibernate.annotations.Formula("IMPORTETOTAL * 0.10") // El cálculo usando SQL
@Stereotype("DINERO")
private BigDecimal beneficioEstimado; // Un campo, como con una propiedad persistente
 
public BigDecimal getBeneficioEstimado() { // Sólo el getter es necesario
    return beneficioEstimado;
}
</code></pre> Esto significa que cuando un <em>DocumentoComercial</em> se lea
      de la base de datos, el campo <em>beneficioEstimado</em> se rellenerá con
      el cálculo de <em>@Formula</em> que es ejecutado por la base de datos. El
      usuario puede filtrar y ordenar por las propiedades <i>@Formula</i> en
      modo lista, pero siempre son de solo lectura y no se recalculan en tiempo
      real en modo detalle. Además, las propiedades <i>@Formula</i> dependen de
      la base de datos, porque podrías usar sintaxis sólo soportada por cierto
      fabricante de base de datos.<br>
      <h2 id="toc10"><a name="Pruebas-JUnit"></a>Pruebas JUnit</h2>
      Antes de ir a la siguiente lección, vamos a escribir el código JUnit para
      ésta. Recuerda, el código no está terminado si no tiene pruebas JUnit.
      Puedes escribir las pruebas antes, durante o después del código principal.
      Pero siempre has de escribirlas.<br>
      El código de prueba mostrado aquí no es solo para darte un buen ejemplo,
      sino también para enseñarte maneras de probar diferentes casos en tu
      aplicación OpenXava.<br>
      <h3 id="toc11"><a name="Pruebas-JUnit-Modificar-la-prueba-existente"></a>Modificar
        la prueba existente</h3>
      Crear una nueva prueba para cada nuevo caso parece una buena idea desde un
      punto de vista estructural, pero en la mayoría de los casos no es
      práctico, porque de esa forma tu código de prueba crecerá muy rápido, y
      con el tiempo, ejecutar todas las pruebas supondrá muchísimo tiempo.<br>
      El enfoque más pragmático es modificar el código de prueba existente para
      cubrir todos los nuevos casos que hemos desarrollado. Hagámoslo de esta
      forma.<br>
      En nuestro caso, la mayoría del código de esta lección aplica a <em>DocumentoComercial</em>,
      por tanto vamos a modificar el método <em>testCrear()</em> de <em>PruebaDocumentoComercial</em>
      para ajustarlo a la nueva funcionalidad. Dejamos el método <em>testCrear()</em>
      tal como muestra el siguiente código:<br>
      <pre><code class="java">public void testCrear() throws Exception {
    login("admin", "admin");
    calcularNumero(); // Añadido para calcular primero el siguiente número de documento
    verificarValoresDefecto();
    escogerCliente();
    anyadirDetalles();
    ponerOtrasPropiedades();
    grabar();
    verificarBeneficioEstimado(); // Prueba @Formula
    verificarCreado();
    borrar();
}
</code></pre> Como ves, añadimos una nueva línea, después de <em>login(...)</em>,
      para calcular el siguiente número de documento, y una llamada al nuevo
      método <em>verificarBeneficioEstimado()</em>.<br>
      Ahora nos conviene más calcular el siguiente número de documento al
      principio para usarlo en el resto de la prueba. Para hacer esto, cambia el
      viejo método <em>getNumero()</em> por los dos métodos mostrados en el
      siguiente código:<br>
      <pre><code class="java">private void calcularNumero() {
    Query query = getManager().createQuery(
        "select max(f.numero) from " +
        modelo + // Cambiamos DocumentoComercial por una variable
        " f where f.anyo = :anyo");
    query.setParameter("anyo", LocalDate.now().getYear());
    Integer ultimoNumero = (Integer) query.getSingleResult();
    if (ultimoNumero == null) ultimoNumero = 0;
    numero = Integer.toString(ultimoNumero + 1);
}
 
private String getNumero() {
    return numero;
}
</code></pre> Anteriormente, teníamos solo <em>getNumero()</em> que calculaba y
      devolvía el número, ahora tenemos un método para calcular (<em>calcularNumero()</em>),
      y otro para devolver el resultado (<em>getNumero()</em>). Puedes notar que
      la lógica del cálculo tiene un pequeño cambio, en vez de usar
      “DocumentoComercial” como fuente de la consulta usamos <i>modelo</i>, una
      variable. Esto es así porque ahora la numeración para facturas y pedidos
      está separada. Llenamos esta variable, un campo de la clase de prueba, en
      el constructor, tal como muestra el siguiente código:<br>
      <pre><code class="java">private String modelo; // Nombre del modelo para la condición. Puede ser 'Factura' o 'Pedido'
 
public PruebaDocumentoComercial(String nombrePrueba, String nombreModulo) {
    super(nombrePrueba, "Facturacion", nombreModulo);
    this.modelo = nombreModulo; // El nombre del módulo coincide con el del modelo
}
</code></pre> En este caso el nombre de módulo, <i>Factura</i> o <i>Pedido</i>,
      coincide con el nombre de modelo, <em>Factura</em> o <em>Pedido</em>,
      así que la forma más fácil de obtener el nombre de modelo es desde el
      nombre de módulo.<br>
      Veamos el código que prueba la nueva funcionalidad.<br>
      <h3 id="toc12"><a name="Pruebas-JUnit-Verificar-valores-por-defecto-propiedades-calculadas-y-Calculation"></a>Verificar
        valores por defecto, propiedades calculadas y <i>@Calculation</i></h3>
      En esta lección hemos hecho algunas modificaciones en los valores por
      defecto. Ahora, el valor por defecto para <em>numero</em> ya no se
      calcula mediante un <em>@DefaultValueCalculator</em> en su lugar usamos
      un método de retrollamada JPA. Para probar este caso hemos de modificar el
      método <em>verificarValoresDefecto()</em> como ves en el siguiente
      código:<br>
      <pre><code class="java">private void verificarValoresDefecto() throws Exception {
    execute("CRUD.new");
    assertValue("anyo", getAnyoActual());
    // assertValue("numero", getNumero()); // Ahora el número no tiene valor inicial...
    assertValue("numero", ""); // ... al crear un documento nuevo
    assertValue("fecha", getFechaActual());
}
</code></pre>Verificamos que <em>numero</em> no tiene valor inicial, porque
      ahora <em>numero</em> no se calcula hasta el momento de grabar el
      documento (sección <a class="wiki_link" href="basic-business-logic_es.html#Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario">Cálculo
        de valor por defecto multiusuario</a>). Cuando el documento (factura o
      pedido) se grabe verificaremos que <em>numero</em> se calcula. </div>
    <div class="wiki" style="display: block;">Cuando la línea se añade podemos
      verificar el cálculo de <em>importe</em> de <em>detalle</em> (la
      propiedad calculada simple, sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Propiedad-calculada-simple">Propiedad
        calculada simple</a>), el valor por defecto para <em>precioPorUnidad</em>
      (<em>@DefaultValueCalculator</em>, sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Usar-DefaultValueCalculator">Usar
        @DefaultValueCalculator</a>) y las propiedades de importes del documento
      (sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Propiedades-de-total-de-una-coleccion">Propiedades
        de total de una colección</a>). Entre las propiedades de total probamos
      <i>porcentajeIVA</i> cuyo valor por defecto se calcula leyendo de un
      archivo de propiedades. Todo esto lo probamos haciendo unas ligeras
      modificaciones en el ya existente método <em>anyadirDetalles()</em>:<br>
      <pre><code class="java">private void anyadirDetalles() throws Exception {
    assertCollectionRowCount("detalles", 0);
	<br>    // Antes de ejecutar esta prueba asegurate de que
    //   producto 1 tenga 19 como precio y 
    //   producto 2 tenga 20 como precio
 
    // Añadir una línea de detalle
    setValueInCollection("detalles", 0, "producto.numero", "1");
    assertValueInCollection("detalles", 0,
        "producto.descripcion", "Peopleware: Productive Projects and Teams");
    assertValueInCollection("detalles", 0,
        "precioPorUnidad", "19,00"); // @DefaultValueCalculator
    setValueInCollection("detalles", 0, "cantidad", "2");
    assertValueInCollection("detalles", 0,
        "importe", "38,00"); // Propiedada calculada, sección 'Propiedad calculada simple'
 
    // Verificando propiedades de total de la colección
    assertTotalInCollection("detalles", 0, "importe", "38,00"); // Suma de importes usando +
    assertTotalInCollection("detalles", 1, "importe", "21"); // Valor por defecto desde un archivo de propiedades
    assertTotalInCollection("detalles", 2, "importe", "7,98"); // IVA, con @Calculation
    assertTotalInCollection("detalles", 3, "importe", "45,98"); // Importe total, con @Calculation
 
    // Añadir otro detalle
    setValueInCollection("detalles", 1, "producto.numero", "2");
    assertValueInCollection("detalles", 1, "producto.descripcion", "Arco iris de lágrimas");
    assertValueInCollection("detalles", 1, "precioPorUnidad", "20,00"); 
    setValueInCollection("detalles", 1, "precioPorUnidad", "10,00"); // Modificando el valor por defecto
    setValueInCollection("detalles", 1, "cantidad", "1");
    assertValueInCollection("detalles", 1, "importe", "10,00");
 
    assertCollectionRowCount("detalles", 2); // Ahora tenemos dos líneas
 
    // Verificando propiedades de total de la colección
    assertTotalInCollection("detalles", 0, "importe", "48,00");
    assertTotalInCollection("detalles", 1, "importe", "21");
    assertTotalInCollection("detalles", 2, "importe", "10,08");
    assertTotalInCollection("detalles", 3, "importe", "58,08");
}
</code></pre>Como ves, con estas modificaciones sencillas probamos la mayoría de
      nuestro nuevo código. Nos quedan sólo las propiedades <em></em><em>beneficioEstimado</em>
      y <i>diasEntrega</i>. Las cuales probaremos en las siguientes secciones.<br>
      <h3 id="toc13"><a name="Pruebas-JUnit-Verificar-Formula"></a>Verificar <em>@Formula</em></h3>
      En la sección <a class="wiki_link" href="basic-business-logic_es.html#Logica-desde-la-base-de-datos-Formula">Lógica
        desde la base de datos</a> hemos creado una propiedad que usa <em>@Formula</em>,
      <em>beneficioEstimado</em>. Esta propiedad se muestra sólo en modo lista.<br>
      Obviamente, la forma más simple de probarlo es yendo a modo lista y
      verificando que el valor para esta propiedad es el esperado. En <em>testCrear()</em>
      llamamos a <em>verificarBeneficioEstimado()</em>. Veamos su código:<br>
      <pre><code class="java">private void verificarBeneficioEstimado() throws Exception {
    execute("Mode.list"); // Cambiar a modo lista
    setConditionValues(new String [] { // Filtra para ver en la lista solamente
        getAnyoActual(), getNumero() // el documento que acabamos de crear
    });
    execute("List.filter"); // Hace filtro
    assertValueInList(0, 0, getAnyoActual()); // Verifica que
    assertValueInList(0, 1, getNumero()); // el filtro ha funcionado
    assertValueInList(0, "beneficioEstimado", "5,81"); // Confirma el beneficio estimado
    execute("List.viewDetail", "row=0"); // Va a modo detalle
}
</code></pre> Dado que ahora vamos a modo lista y después volvemos a detalles,
      hemos de hacer una pequeña modificación en el método <em>verificarCreado()</em>,
      que es ejecutado justo después de <em>verificarBeneficioEstimado()</em>.
      Veamos la modificación:<br>
      <pre><code class="java">private void verificarCreado() throws Exception {
    // setValue("anyo", getAnyoActual()); // Borramos estas líneas
    // setValue("numero", getNumero());  // para buscar el documento
    // execute("CRUD.refresh"); // porque ya lo hemos buscado desde el modo lista
    // El resto de la prueba ...
    ...
</code></pre> Quitamos estas líneas porque ahora no es necesario buscar el
      documento recién creado. Ahora en el método <em>verificarBeneficioEstimado()</em>
      vamos a modo lista y escogemos el documento, por tanto ya estamos editando
      el documento.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="Pruebas-JUnit-Probar-sincronizacion-de-propiedades-calculadas-y-persistentes"></a>Probar
        sincronización de propiedades calculadas y persistentes</h3>
      En la sección <a class="wiki_link" href="basic-business-logic_es.html#Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas">Sincronizar
        propiedades persistentes y calculadas</a> usamos métodos de retrollamada
      JPA en <em>Pedido</em> para tener una propiedad persistente, <em>diasEntrega</em><em></em>,
      sincronizada con una calculada, <em>diasEntregaEstimados</em>. La
      propiedad <em>diasEntrega</em> sólo se muestra en modo lista.<br>
      Ve a la clase <i>PruebaPedido</i> y añade un nuevo método <i>testDiasEntrega()</i>:<br>
      <pre><code class="java">public void testDiasEntrega() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); 
    execute("List.viewDetail", "row=0"); 
	
    setValue("fecha", "5/6/2020");
    assertValue("diasEntregaEstimados", "1");
    setValue("fecha", "6/6/2020");
    assertValue("diasEntregaEstimados", "3");
    setValue("fecha", "7/6/2020");
    assertValue("diasEntregaEstimados", "2");
    execute("CRUD.save");
    execute("Mode.list"); // Para verificar que diasEntrega está sincronizado
    assertValueInList(0, "diasEntrega", "2"); 

    execute("List.viewDetail", "row=0");
    setValue("fecha", "13/1/2020");
    assertValue("diasEntregaEstimados", "7");
    execute("CRUD.save");
    execute("Mode.list"); // Para verificar que diasEntrega está sincronizado
    assertValueInList(0, "diasEntrega", "7");        
}
</code></pre>Probamos varios valores para <i>fecha</i> para verificar que <i>diasEntregaEstimados</i>
      se calcula correctamente cada vez, además vamos a modo lista para
      verificar que <i>diasEntrega</i> tiene el valor correcto y por tanto
      ambas propiedades están sincronizadas.
      <div class="wiki" style="display: block;"><br>
      </div>
    </div>
    <div class="wiki" style="display: block;"> ¡Enhorabuena! Ahora tus pruebas
      ya están sincronizadas con tu código. Es un buen momento para ejecutar
      todas las pruebas de tu aplicación.<br>
      <h2 id="toc14"><a name="Resumen"></a>Resumen</h2>
      En esta lección has aprendido algunas formas comunes de añadir lógica de
      negocio a tus entidades. No hay duda sobre la utilidad de las propiedades
      calculadas, <i>@Calculation</i>, los métodos de retrollamada o <em>@Formula</em>.
      Sin embargo, todavía tenemos muchas otras formas de añadir lógica a tu
      aplicación OpenXava, que vamos a aprender a usar.<br>
      En futuros lecciones verás como añadir validación, modificar el
      funcionamiento estándar del módulo y añadir tu propia lógica de negocio,
      entre otras formas de añadir lógica personalizada a tu aplicación.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-5-basic-business-logic_es.zip/download"

          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="validation_es.html">Ve a la lección 6</a></strong>
    </div>
  </body>
</html>
